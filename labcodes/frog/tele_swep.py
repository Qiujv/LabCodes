"""Process teleportation tomo datas generated by swep experiments instead of single shot results."""

import logging
from itertools import product
from typing import Literal, Union

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

import labcodes.frog.tele_state as ts
import labcodes.frog.tele_gate as tg
import labcodes.frog.pyle_tomo as tomo
from labcodes import fileio, misc, plotter

logger = logging.getLogger(__name__)

class qpt_tele_state:
    """For state teleportation qpt data.
    
    >>> lf = fileio.read_labrad('//XLD2-PC2/labRAD_data/crab.dir/230716.dir/230807_245_tele_fb.dir', 433)
    >>> qpt = qpt_tele_state(lf)
    >>> qpt.plot_chi()
    <Figure size 800x500 with 8 Axes>
    """
    def __init__(self, lf:fileio.LogFile, kind: Literal['fb', 'ps'] = None):
        self.lf = lf
        df = lf.df
        if 'run' not in df: df['run'] = 0  # For data with only one run.
        df = df.groupby('run').filter(lambda df: len(df) == 12)
        df['tomo_op'] = df['tomo_op'].replace(dict(zip([0,1,2], '0xy')))
        df['init_state'] = df['init_state'].replace(dict(zip([0,1,2,3], '0xy1')))
        self.df = df

        if kind is None:
            title = self.lf.name.title.lower()
            if '_ps' in title or '(ps)' in title:
                kind = 'ps'
            else:
                kind = 'fb'
        
        if kind == 'ps':
            self.rho_ideal = ts.rho_out_ideal_ps
            self.chi_ideal = ts.chi_ideal_ps
        elif kind == 'fb':
            self.rho_ideal = ts.rho_out_ideal_fb
            self.chi_ideal = ts.chi_ideal_fb
        else:
            raise ValueError(f'kind {kind} not recognized')
        
        self.selects = ('00', '01', '10', '11')
        self.rho_in = ts.rho_in
        self._rho = {select: {} for select in self.selects}
        self._chi = {select: {} for select in self.selects}
        try:
            self.constuct_all()
        except:
            logger.exception(f'failed to construct rho and chi for {self.lf.name}')

    def probs(
        self, 
        run: Union[int, Literal['mean', 'ideal']] = 0, 
        init_state: Literal['0', 'x', 'y', '1'] = '0', 
        select: Literal['00', '01', '10', '11'] = '00',
    ) -> pd.DataFrame:
        probs = self.df.query(f'run == {run} & init_state == "{init_state}"')
        probs = probs.set_index('tomo_op').loc[list('0xy'), [f'p{select}0', f'p{select}1']]
        p_select = probs.sum(axis='columns')  # TODO: include this in result.
        probs = probs.divide(p_select, axis='index')
        return probs

    def rho(
        self, 
        run: Union[int, Literal['mean', 'ideal']] = 0, 
        init_state: Literal['0', 'x', 'y', '1'] = '0', 
        select: Literal['00', '01', '10', '11'] = '00',
    ) -> np.ndarray:
        if run in self._rho[select]:
            if init_state in self._rho[select][run]:
                return self._rho[select][run][init_state]
            
        if run == 'mean':
            return np.mean([self.rho(run, init_state, select) 
                            for run in self.df['run'].unique()], axis=0)
        
        if run == 'ideal':
            return self.rho_ideal[select][init_state]
        
        probs = self.probs(run, init_state, select)
        return tomo.qst(probs.values, 'tomo')

    def chi(
        self, 
        run: Union[int, Literal['mean', 'ideal']] = 0, 
        select: Literal['00', '01', '10', '11'] = '00',
    ) -> np.ndarray:
        if run in self._chi[select]:
            return self._chi[select][run]
        
        if run == 'mean':
            return np.mean([self.chi(run, select) 
                            for run in self.df['run'].unique()], axis=0)
        
        if run == 'ideal':
            return self.chi_ideal[select]
        
        return tomo.qpt(
            [self.rho_in[init] for init in '0xy1'],
            [self.rho(run, init, select) for init in '0xy1'],
            'sigma',
        )
    
    def constuct_all(self) -> None:
        for run in self.df['run'].unique():
            if len(self.df.query(f'run == {run}')) != 12:
                logger.warning(f'run {run} does not have 12 tomo points')
                continue
            for select in self.selects:
                rho = {init: self.rho(run, init, select) for init in '0xy1'}
                self._rho[select][run] = rho
                chi = self.chi(run, select)
                self._chi[select][run] = chi

    @property
    def Frho(self) -> pd.DataFrame:
        records = []
        for run in self.df['run'].unique():
            for select in self.selects:
                rec = {'run': run, 'select': select}
                for init in '0xy1':
                    rec[f'F{init}'] = misc.fidelity(
                        self.rho(run, init, select),
                        self.rho_ideal[select][init.lower()],
                    )
                records.append(rec)
        return pd.DataFrame.from_records(records)
    
    @property
    def Fchi(self) -> pd.DataFrame:
        records = []
        for run in self.df['run'].unique():
            for select in self.selects:
                rec = {'run': run, 'select': select}
                rec['Fchi'] = misc.fidelity(self.chi(run, select),
                                            self.chi_ideal[select])
                records.append(rec)
        return pd.DataFrame.from_records(records)
    
    @property
    def fname(self) -> fileio.LogName:
        fname = self.lf.name.copy()
        fname.title = fname.title + f' Fchi_mean={self.Fchi["Fchi"].mean():.2%}'
        return fname
    
    def dump_chi(self, fname: str = 'chi_exp.json', run='mean'):
        chi_mean = {select: self.chi(run, select) for select in self.selects}
        chi_mean['id'] = self.lf.name.id
        return fileio.data_to_json(chi_mean, fname)

    def plot_chi_4x2(self, run: Union[int, Literal['mean', 'ideal']] = 'mean') -> plt.Figure:
        chi_dict = {select: self.chi(run, select) for select in self.selects}

        fig = plt.figure(figsize=(14,8), tight_layout=False)
        for i, (select, mat) in enumerate(chi_dict.items()):
            ax_r:plt.Axes = fig.add_subplot(2, 4, 2*i+1, projection='3d')
            ax_i:plt.Axes = fig.add_subplot(2, 4, 2*i+2, projection='3d')
            plotter.plot_complex_mat3d(mat, [ax_r, ax_i], cmin=-1, cmax=1, colorbar=False)
            # Ok for run=='mean' because `fid` is linear.
            fid = misc.fidelity(mat, self.chi_ideal[select])
            ax_r.set_title(f'select={select}, Fchi={fid:.2%}')
            ax_r.collections[0].set_linewidth(0.2)
            ax_r.set_xticklabels('IXYZ')
            ax_r.set_yticklabels('IXYZ')
            ax_i.collections[0].set_linewidth(0.2)
            ax_i.set_xticklabels('IXYZ')
            ax_i.set_yticklabels('IXYZ')

        cax = fig.add_axes([0.4, 0.5, 0.2, 0.01])
        fig.colorbar(ax_r.collections[0], cax=cax, orientation='horizontal')
        fig.suptitle(self.fname.as_plot_title(width=100))
        return fig
    
    def plot_chi(self, run: Union[int, Literal['mean', 'ideal']] = 'mean') -> plt.Figure:
        chi_dict = {select: self.chi(run, select) for select in self.selects}
        fig, axs = plt.subplots(ncols=4, nrows=2, figsize=(8, 5), sharex=True, sharey=True)
        for i, (select, mat) in enumerate(chi_dict.items()):
            ax_r = axs.ravel()[2*i]
            ax_i = axs.ravel()[2*i+1]
            plotter.plot_mat(mat.real, .3, -.3, ax=ax_r, vary_size=True, fmt='{:.1%}'.format, omit_below=3e-3)
            plotter.plot_mat(mat.imag, .3, -.3, ax=ax_i, vary_size=True, fmt='{:.1%}'.format, omit_below=3e-3)
            fid = misc.fidelity(mat, self.chi_ideal[select])
            ax_r.set_title(f'select={select}, Fchi={fid:.2%}')
        ax_r.set_xticks(range(4))
        ax_r.set_yticks(range(4))
        ax_r.set_xticklabels([])
        ax_r.set_yticklabels('IXYZ')
        fname = self.fname.copy()
        fname.title = fname.title + f' run={run}'
        fig.suptitle(fname.as_plot_title(width=100))
        # cax = fig.add_axes([0.04, 0.9, 0.1, 0.01])
        # fig.colorbar(fig.axes[0].collections[0], cax=cax, extend='both', location='top', 
        #              orientation='horizontal', label=f'run={run}', ticks=[-.3,.3])
        return fig
    
    def plot_rho(self, run: Union[int, Literal['mean', 'ideal']] = 'mean') -> plt.Figure:
        fig = plt.figure(figsize=(10, 5), layout='constrained')
        subfigs = fig.subfigures(ncols=4, nrows=1, wspace=0.02)
        for ic, select in enumerate(self.selects):
            subfig = subfigs[ic]
            fchi = misc.fidelity(self.chi(run, select), self.chi_ideal[select])
            subfig.suptitle(f'select={select}, Fchi={fchi:.2%}')
            axs = subfig.subplots(ncols=2, nrows=4, sharex=True, sharey=True, gridspec_kw=dict(wspace=0))
            for ir, init in enumerate('0xy1'):
                ax_r = axs[ir, 0]
                ax_i = axs[ir, 1]
                mat = self.rho(run, init, select)
                plotter.plot_mat(mat.real, .5, -.5, ax=ax_r, vary_size=True, fmt='{:.1%}'.format, omit_below=3e-3)
                plotter.plot_mat(mat.imag, .5, -.5, ax=ax_i, vary_size=True, fmt='{:.1%}'.format, omit_below=3e-3)
                fid = misc.fidelity(mat, self.rho_ideal[select][init])
                ax_r.set_ylabel(f'init={init},\nFrho={fid:.2%}')
            ax_r.set_xticks([])
        fname = self.fname.copy()
        fname.title = fname.title + f' run={run}'
        fig.suptitle(fname.as_plot_title(width=100))
        # cax = fig.add_axes([0.03, 0.92, 0.1, 0.01])
        # fig.colorbar(fig.axes[0].collections[0], cax=cax, extend='both', location='top', 
        #              orientation='horizontal', label=f'run={run}', ticks=[-.5,.5])
        return fig
    
    def plot_fidelity(self) -> plt.Figure:
        df = pd.concat(
            [self.Fchi.set_index(['run', 'select']), 
            self.Frho.set_index(['run', 'select'])],
            axis='columns',
        ).reset_index()

        fig, axs = plt.subplots(nrows=5, sharex=True, figsize=(6,6))
        def plot_panel(ax:plt.Axes, df:pd.DataFrame, yname:str):
            ax.plot('run', yname, data=df.query('select=="00"'), label='00')
            ax.plot('run', yname, data=df.query('select=="01"'), label='01')
            ax.plot('run', yname, data=df.query('select=="10"'), label='10')
            ax.plot('run', yname, data=df.query('select=="11"'), label='11')
            ymean = df[yname].mean()
            plotter.cursor(ax=ax, y=ymean, text=f'{ymean:.2%}', text_style=dict(ha='right'))
            ax.set_ylabel(yname)
        plot_panel(axs[0], df, 'Fchi')
        plot_panel(axs[1], df, 'F0')
        plot_panel(axs[2], df, 'Fx')
        plot_panel(axs[3], df, 'Fy')
        plot_panel(axs[4], df, 'F1')
        axs[1].legend(ncols=4, loc='center left')
        axs[-1].set_xlabel('run')
        fig.suptitle(self.fname.as_plot_title())
        return fig


class qpt_tele_gate:
    TOMO_OPS = ('00','0x','0y','x0','xx','xy','y0','yx','yy')
    QPT_INITS = ('00','0x','0y','01','x0','xx','xy','x1','y0','yx','yy','y1','10','1x','1y','11')
    """For gate teleportation qpt data."""
    def __init__(self, lf:fileio.LogFile, kind: Literal['fb', 'ps'] = None):
        self.lf = lf
        df = lf.df
        if 'run' not in df: df['run'] = 0  # For data with only one run.
        df = df.groupby('run').filter(lambda df: len(df) == 144)
        tomo_ops = [i.lower() for i in lf.conf['parameter']['-tomo_ops']]
        init_states = [i.lower() for i in lf.conf['parameter']['-init_states']]
        df['tomo_op'] = df['tomo_op'].replace(dict(enumerate(tomo_ops)))
        df['init_state'] = df['init_state'].replace(dict(enumerate(init_states)))
        self.df = df

        if kind is None:
            title = self.lf.name.title.lower()
            if '_ps' in title or '(ps)' in title:
                kind = 'ps'
            else:
                kind = 'fb'
        
        if kind == 'ps':
            self.rho_ideal = tg.rho_out_ideal_ps
            self.chi_ideal = tg.chi_ideal_ps
        elif kind == 'fb':
            self.rho_ideal = tg.rho_out_ideal_fb
            self.chi_ideal = tg.chi_ideal_fb
        else:
            raise ValueError(f'kind {kind} not recognized')
        
        self.selects = ('00', '01', '10', '11')
        self.rho_in = tg.rho_in
        self._rho = {select: {} for select in self.selects}
        self._chi = {select: {} for select in self.selects}
        try:
            self.constuct_all()
        except:
            logger.exception(f'failed to construct rho and chi for {self.lf.name}')

    def probs(
        self, 
        run: Union[int, Literal['mean', 'ideal']] = 0, 
        init_state: str = '00', 
        select: Literal['00', '01', '10', '11'] = '00',
    ) -> pd.DataFrame:
        probs = self.df.query(f'run == {run} & init_state == "{init_state}"')
        probs = probs.set_index('tomo_op').loc[self.TOMO_OPS, [f'p0{select}0', f'p0{select}1', f'p1{select}0', f'p1{select}1']]
        p_select = probs.sum(axis='columns')  # TODO: include this in result.
        probs = probs.divide(p_select, axis='index')
        return probs

    def rho(
        self, 
        run: Union[int, Literal['mean', 'ideal']] = 0,
        init_state: str = '00',
        select: Literal['00', '01', '10', '11'] = '00',
    ) -> np.ndarray:
        if run in self._rho[select]:
            if init_state in self._rho[select][run]:
                return self._rho[select][run][init_state]

        if run == 'mean':
            return np.mean([self.rho(run, init_state, select) 
                            for run in self.df['run'].unique()], axis=0)

        if run == 'ideal':
            return self.rho_ideal[select][init_state]

        probs = self.probs(run, init_state, select)
        return tomo.qst(probs.values, 'tomo2')

    def chi(
        self, 
        run: Union[int, Literal['mean', 'ideal']] = 0, 
        select: Literal['00', '01', '10', '11'] = '00',
    ) -> np.ndarray:
        if run in self._chi[select]:
            return self._chi[select][run]
        
        if run == 'mean':
            return np.mean([self.chi(run, select) 
                            for run in self.df['run'].unique()], axis=0)
        
        if run == 'ideal':
            return self.chi_ideal[select]
        
        return tomo.qpt(
            [self.rho_in[init] for init in self.QPT_INITS],
            [self.rho(run, init, select) for init in self.QPT_INITS],
            'sigma2',
        )
    
    def constuct_all(self) -> None:
        for run in self.df['run'].unique():
            if len(self.df.query(f'run == {run}')) != 144:
                logger.warning(f'run {run} does not have 144 tomo points')
                continue
            for select in self.selects:
                rho = {init: self.rho(run, init, select) for init in self.QPT_INITS}
                self._rho[select][run] = rho
                chi = self.chi(run, select)
                self._chi[select][run] = chi

    @property
    def Frho(self) -> pd.DataFrame:
        records = []
        for run in self.df['run'].unique():
            for select in self.selects:
                rec = {'run': run, 'select': select}
                for init in self.QPT_INITS:
                    rec[f'F{init}'] = misc.fidelity(
                        self.rho(run, init, select),
                        self.rho_ideal[select][init.lower()],
                    )
                records.append(rec)
        return pd.DataFrame.from_records(records)
    
    @property
    def Fchi(self) -> pd.DataFrame:
        records = []
        for run in self.df['run'].unique():
            for select in self.selects:
                rec = {'run': run, 'select': select}
                rec['Fchi'] = misc.fidelity(self.chi(run, select),
                                            self.chi_ideal[select])
                records.append(rec)
        return pd.DataFrame.from_records(records)
    
    @property
    def fname(self) -> fileio.LogName:
        fname = self.lf.name.copy()
        fname.title = fname.title + f' Fchi_mean={self.Fchi["Fchi"].mean():.2%}'
        return fname
    
    def dump_chi(self, fname: str = 'chi_exp.json', run='mean'):
        chi_mean = {select: self.chi(run, select) for select in self.selects}
        chi_mean['id'] = self.lf.name.id
        return fileio.data_to_json(chi_mean, fname)
    
    def plot_chi_4x2(self, run: Union[int, Literal['mean', 'ideal']] = 'mean') -> plt.Figure:
        chi_dict = {select: self.chi(run, select) for select in self.selects}

        ticklabels = [i+j for i,j in product('IXYZ', repeat=2)]
        fig = plt.figure(figsize=(14,8), tight_layout=False)
        for i, (select, mat) in enumerate(chi_dict.items()):
            ax_r:plt.Axes = fig.add_subplot(2, 4, 2*i+1, projection='3d')
            ax_i:plt.Axes = fig.add_subplot(2, 4, 2*i+2, projection='3d')
            plotter.plot_complex_mat3d(mat, [ax_r, ax_i], cmin=-.25, cmax=.25, 
                                    colorbar=False, label=False)
            # Ok for run=='mean' because `fid` is linear.
            fid = misc.fidelity(mat, self.chi_ideal[select])
            ax_r.set_title(f'select={select}, Fchi={fid:.2%}')
            for ax in ax_r, ax_i:
                ax.set_zlim(-0.25,0.25)
                ax.set_zticks([0, 0.25])
                ax.collections[0].set_linewidth(0.2)
                ax.set_xticklabels(ticklabels)
                ax.set_yticklabels(ticklabels)
                ax.tick_params('both', pad=0, labelsize='small')
                ax.tick_params('x', labelrotation=45)
                ax.tick_params('y', labelrotation=-45)

        cax = fig.add_axes([0.4, 0.5, 0.2, 0.01])
        fig.colorbar(ax_r.collections[0], cax=cax, orientation='horizontal')
        fig.suptitle(self.fname.as_plot_title(width=100))
        return fig